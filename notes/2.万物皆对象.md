# 对象操纵

所有的编程语言都会操纵内存中的元素，Java 中操纵的标识符实际上只是对对象的 **引用[^1]**。**引用** 并不意味着你必然有一个与之关联的 **对象**。

>[^1]: Java 引用的语法更类似于 C++ 的引用而非指针。Java 对象标识符实际上是 **对象引用（object references）**，并且都是值传递。==所以你不是通过引用传递，而是通过值传递对象引用==。



**代码示例：**

```java
String s;
```

上面代码只是创建了一个 `String` 对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量 `s` 赋值（指向任何对象）。通常更安全的做法是：**创建一个引用的同时进行初始化**。

**代码示例：**

```java
String s = "hello";
```



# 对象创建

## 数据存储

**有 5 个不同的地方可以存储数据：**

1. **寄存器（Registers）**：最快的存储区域，位于 CPU 内部。

    >寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（C/C++ 允许开发者向编译器建议寄存器的分配）。

2. **栈内存（Stack）**：存在于 **常规内存 RAM（随机访问存储器，Random Access Memory）** 区域中，可通过栈指针获得处理器的直接支持。==栈指针下移分配内存，上移释放内存。==

    >效率仅次于寄存器。创建程序时，Java 系统必须知道栈内保存的所有项的生命周期，这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据（如对象引用），但 Java 对象本身的数据却是保存在堆内存的。

3. **堆内存（Heap）**：这是一种通用的内存池（也在 RAM 区域），==所有 Java 对象都存在于其中==。

    > 与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间，**用堆内存保存数据更具灵活性**。创建一个对象时，只需用 `new` 命令实例化对象即可，**当执行代码时，会自动在堆中进行内存分配**。

4. **常量存储（Constant storage）**：常量值通常直接放在程序代码中，因为它们永远不会改变。

    > - 如需严格保护，可考虑将它们置于 **只读存储器 ROM （只读存储器，Read Only Memory）** 中。
    >
    > - 比如 **字符串常量池**，所有文字字符串和字符串值常量表达式都会自动放入特殊的静态存储中。

5. **非 RAM 存储（Non-RAM storage）**：数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。

    1. 序列化对象：对象被转换为字节流，通常被发送到另一台机器；
    2. 持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。

    > 这些存储的方式都是 **将对象转存于另一个介质中，并在需要时恢复成常规的、基于 RAM 的对象**。Java 为轻量级持久化提供了支持。



## 基本类型的存储

==Java 基本类型的创建不是通过 `new` 关键字来产生，而是使用一个 **自动变量** ，这个变量直接存储 **值**，并置于 **栈内存** 中。== 



**Java 确定了每种基本类型的内存占用大小，这些大小不会随着机器环境的变化而改变。**

| 基本类型 |  大小   |  最小值   |      最大值       | 包装类型  |
| :------: | :-----: | :-------: | :---------------: | :-------: |
| boolean  |    -    |     -     |         -         |  Boolean  |
|   char   | 16 bits | Unicode 0 | Unicode 2^16^ - 1 | Character |
|   byte   | 8 bits  |   - 128   |       + 127       |   Byte    |
|  short   | 16 bits |  - 2^15^  |    + 2^15^ - 1    |   Short   |
|   int    | 32 bits |  - 2^31^  |    + 2^31^ - 1    |  Integer  |
|   long   | 64 bits |  - 2^63^  |    + 2^63^ - 1    |   Long    |
|  float   | 32 bits |  IEEE754  |      IEEE754      |   Float   |
|  double  | 64 bits |  IEEE754  |      IEEE754      |  Double   |
|   void   |    -    |     -     |         -         |   Void    |

所有的数值类型都是有正/负符号的。**布尔（boolean）类型的大小没有明确的规定，通常定义为取字面值 `true` 或 `false`。**

==如果希望在堆内存里表示基本类型的数据，就使用它们的包装类。==



**代码示例：**

```java
char c = 'a';
Character ch = new Character(c);
```

或者

```java
Character ch = new Character('a');
```

**基本类型自动转换成包装类型（自动装箱）**

```java
Character ch = 'a';
```

**包装类型转化为基本类型（自动拆箱）**

```java
char c = ch;
```



## 高精度数值

Java 中有两种类型的数据可用于高精度的计算。分别是 `BigInteger` 和 `BigDecimal`。大致可以划归为 **包装类型**，没有对应的 **基本类型**。



能对 `int` 和 `float` 做的运算，同样适用于 `BigInteger` 和 `BigDecimal`，但必须要通过调用它们的方法来实现而非运算符。



**区别：**

1. `BigInteger` 支持任意精度的整数，可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。
2. `BigDecimal` 支持任意精度的定点数字，可用于进行精确的货币计算。



## 数组的存储

==在 Java 中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。==



**当创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为 `null`。在使用该数组之前，必须为每个引用指定一个对象，如果尝试使用为 `null` 的引用，则会在运行时报错。**



**创建基本类型的数组，编译器通过将该数组的内存全部置零来保证初始化。**



# 对象清理

## 作用域

==作用域决定了在该范围内定义的变量名的可见性和生存周期。==

**作用域是由大括号 `{}` 的位置决定的，例如：**

```java
{
	int x = 12;
	// 仅 x 变量可用
	{
		int q = 96;
		// x 和 q 变量皆可用
	}
	// 仅 x 变量可用
	// 变量 q 不在作用域内
}
```

**Java  的变量只有在其作用域内才可用。**

```java
{
	int x = 12;
	{
		int x = 96;
	}
}
```

上例中，Java 编译器会提示变量 x 已经被定义过了，不被允许，在 C/C++中被允许。



## 对象作用域

==Java 对象与基本类型具有不同的生命周期。当使用 `new ` 关键字来创建 Java 对象时，它的生命周期将会超出作用域。==

**代码示例：**

```java
{
	String s = new String("a string");
}
// 作用域终点
```

上例中，引用 `s` 在作用域终点就结束了。但是，引用 `s` 指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用 `s` 已经超出了作用域的范围。



**若有需要，`new` 出来的对象就会一直存活下去。**

>问：在 Java 中并没有主动清理这些对象，那么如何避免 C++ 中出现的内存被填满从而阻塞程序的问题？
>
>答：Java 的垃圾收集器会检查所有 `new` 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用，有效防止了 **内存泄露** 问题。



# 类的创建

## 类型

==`class` 关键字决定了某一类对象的 **外观和行为**。==

**代码示例：**

```java
class ATypeName {
	// 这里是类的内部
}
```

通过 `new ` 关键字来创建一个这种类型的对象，如下：

```java
ATypeName a = new ATypeName();
```



## 字段

创建好一个类之后，可以往类里存放两种类型的元素：**方法（method）** 和 **字段（field）**。**类的字段可以是基本类型，也可以是引用类型**。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上。每个对象都有用来存储其字段的空间。

**代码示例：**

```java
class DataOnly {
	int i;
	double d;
	boolean b;
}
```

这个类只能存储数据。但仍然可以创建一个它的对象：

```java
DataOnly data = new DataOnly();
```

必须通过这个对象的引用来指定字段值：

> 格式：`对象名称.方法名称或字段名称`

```java
data.i = 1;
data.d = 1.1;
data.b = false;
```



## 基本类型默认值

**如果类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。**

| 基本类型 |    初始值    |
| :------: | :----------: |
| boolean  |    false     |
|   char   | \u0000(null) |
|   byte   |   (byte)0    |
|  short   |   (short)0   |
|   int    |      0       |
|   long   |      0L      |
|  float   |     0.0f     |
|  double  |     0.0d     |

==这些默认值仅在 Java 初始化类的时候才会被赋予，确保了基本类型的字段始终能被初始化，为了安全最好显式地初始化变量。==



**这种默认值的赋予并不适用于局部变量（不属于类的字段的变量）。在方法中定义的基本类型数据，如下：**

```java
int x;
```

这里的变量 `x` 不会自动初始化为 0，因而在使用变量 `x` 之前，要主动为其赋值，否则 Java 会提示 **编译时错误，该变量可能尚未被初始化**。



## 方法使用

==在 Java 中，使用术语 **方法（method）** 来表示 **做某事的方式**。==



==在 Java 中，**方法** 决定对象能接受哪些消息。方法的基本组成部分包括：**名称**、**参数**、**返回类型**、**方法体**。==

**格式如下：**

```java
[返回类型] [方法名](参数列表){
	// 方法体
}
```

### 返回类型

==方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为 **方法签名（signature of the method）**。**签名作为方法的唯一标识**。==



**Java 中的方法只能作为类的一部分创建。它只能被对象所调用，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。**



**调用方法代码示例：**

```java
[对象引用].[方法名](参数1, 参数2, 参数3)；
```

若方法不带参数，例如一个对象引用 `a` 的方法 `f` 不带参数并且返回 `int` 型结果，可以如下表示：

```java
int x = a.f();
```

上例中方法 `f` 的返回值类型必须和变量 `x` 的类型兼容。

==调用方法的行为就是 **向对象发送消息**。==

### 参数列表

**方法参数列表指定了传递给方法的信息（以对象的形式传递），参数列表必须指定每个对象的类型和名称。**

> 除了基本数据类型，通常传递对象就意味着传递对象的引用。



**代码示例：**

```java
int storage(String s) {
	return s.length() * 2;
}
```

此方法计算并返回某个字符串所占的字节数。参数 `s` 的类型为 `String`，将 `s` 传递给 `storage()` 后，我们可以把它看做和任何其他对象一样，可以向它发送消息。`return` 关键字执行两项操作：首先，它意味着 **方法执行结束**；其次，如果方法有返回值，那么该值就紧跟 `return` 语句之后，这里是通过 `s.length() * 2` 计算产生的。

**在方法中，可以返回任何类型的数据**。如果不想方法返回数据，则可以通过给方法标识 `void` 来表明，如下：

```java
boolean flag() {
	return true;
}

void nothing() {
	return;
}

void nothing1() {
	
}
```

**当返回类型为 `void` 时，`return` 关键字仅用于退出方法，因此可以省略。**



# 程序编写

## 命名可见性

**Java 使用反向 URL 将命名空间与文件路径相关联。**



## 使用其他组件

**必须通过使用 `import` 关键字来告诉 Java编译器具体要使用的类。**



## static 关键字

==通常只有在使用 `new` 创建类的对象后，数据存储空间才被分配，对象的方法才能供外界调用==，以下两种情况例外：

1. 只为特定字段（也称：属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本不创建对象；
2. 创建一个与此类的任何对象无关的方法。也就是说，即时没有创建对象，也能调用该方法。

**`static` 关键字符合上述两点要求**。当我们说某个事物是 **静态** 时，就意味着 **该字段或方法不依赖于任何特定的对象实例**。**即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段**。相反，对于普通的非静态字段和方法，我们必须要先创建一个对象并使用该对象来访问字段或方法，因为 **非静态字段和方法必须与特定对象关联**。

> 静态方法在使用之前不需要创建对象，因此它们 **不能直接调用非静态的成员或方法（非静态成员和方法必须要先实例化为对象才可以被使用）**。



一些面向对象的语言使用 **类数据（class data）** 和 **类方法（class method）**，==表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。==



**代码示例：**

```java
class StaticTest {
	static int i = 47;
}
```

现在，即使你创建了两个 `StaticTest` 对象，但是静态变量 `i` 仍只占一份存储空间。**两个对象都会共享相同的变量 `i`**，如下：

```java
StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
```

**`st1.i` 和 `st2.i` 指向同一块存储空间，因此它们的值都是 47。**



**引用静态变量和静态方法的两种办法：**

1. 通过一个对象来引用；
2. 通过类名引用。

> 通过类名引用静态变量是首选方法，因为它 **强调了变量的静态属性**。



**代码示例：**

```java
class Incrementable {
	static void increment() {
		StaticTest.i++;
	}
}
```

上例中，`Incrementable` 的 `increment()` 方法通过 `++` 运算符将静态数据 `i` 加 1。可以先实例化对象再调用该方法，如下：

```java
Incrementable sf = new Incrementable();
sf.increment();
```

首选的方法是直接通过类来调用它，如下：

```java
Incrementable.increment();
```



**相比非静态的对象，`static` 属性改变了数据创建的方式。**

